<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisation de la Zone de Tonte</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #1f2937;
        }
        canvas {
            background-color: #e2e8f0;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="bg-gray-100 p-4 sm:p-6">

    <div class="bg-white p-6 sm:p-8 rounded-2xl shadow-xl w-full max-w-2xl text-center">
        <h1 class="text-3xl sm:text-4xl font-bold mb-4 text-indigo-700">Visualisation de la Zone</h1>
        <p class="text-gray-600 mb-6">Tracé du dernier parcours enregistré du robot tondeuse.</p>
        
        <!-- Canvas pour la visualisation -->
        <div class="relative w-full aspect-square">
            <canvas id="mowingCanvas" class="w-full h-full"></canvas>
            <!-- Indicateur de chargement -->
            <div id="loadingIndicator" class="absolute inset-0 flex items-center justify-center bg-white bg-opacity-80 rounded-2xl z-10 hidden">
                <div class="animate-spin rounded-full h-12 w-12 border-4 border-indigo-500 border-t-transparent"></div>
            </div>
        </div>

        <!-- Section pour les informations sur le parcours -->
        <div class="mt-6 text-left">
            <h2 class="text-2xl font-semibold mb-2 text-gray-800">Détails du Parcours</h2>
            <p class="text-gray-600">Distance totale parcourue : <span id="totalDistance" class="font-medium text-gray-800">0 m</span></p>
            <p class="text-gray-600">Temps de tonte : <span id="mowingTime" class="font-medium text-gray-800">0 min</span></p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('mowingCanvas');
            const ctx = canvas.getContext('2d');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const totalDistanceDisplay = document.getElementById('totalDistance');
            const mowingTimeDisplay = document.getElementById('mowingTime');
            const pageTitle = document.querySelector('h1');

            const DISTANCE_TO_PIXEL_RATIO = 1;

            const drawPath = (vectors) => {
                if (!vectors || vectors.length === 0) {
                    loadingIndicator.innerHTML = '<p class="text-red-600 font-semibold">Impossible de charger les données du tracé.</p>';
                    return;
                }
                loadingIndicator.style.display = 'none';
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Centrage et mise à l'échelle automatique du tracé
                let minX = 0, maxX = 0, minY = 0, maxY = 0;
                let x = 0, y = 0, angle = -90;
                const pathPoints = [{x: 0, y: 0, type: 'start'}];
                console.log(`DEBUG: Traitement de ${vectors.length} vecteurs`);
                
                vectors.forEach((v, index) => {
                    console.log(`Vecteur ${index}: distance=${v.distance}, angle=${v.relative_angle}`);
                    
                    // Appliquer la rotation
                    if (v.relative_angle && v.relative_angle !== 0) {
                        angle += v.relative_angle;
                        console.log(`Rotation: nouvel angle = ${angle.toFixed(1)}°`);
                        pathPoints.push({x: x, y: y, type: 'rotation', angle: angle});
                    }
                    
                    // Appliquer le mouvement
                    if (v.distance && v.distance > 0) {
                        const angleRad = angle * Math.PI / 180;
                        const newX = x + v.distance * Math.cos(angleRad);
                        const newY = y + v.distance * Math.sin(angleRad);
                        
                        console.log(`Mouvement: de (${x.toFixed(1)}, ${y.toFixed(1)}) à (${newX.toFixed(1)}, ${newY.toFixed(1)})`);
                        pathPoints.push({x: newX, y: newY, type: 'movement'});
                        
                        minX = Math.min(minX, x, newX);
                        maxX = Math.max(maxX, x, newX);
                        minY = Math.min(minY, y, newY);
                        maxY = Math.max(maxY, y, newY);
                        
                        x = newX;
                        y = newY;
                    }
                });

                vectors.forEach(v => {
                    angle += v.relative_angle;
                    const angleRad = angle * Math.PI / 180;
                    x += v.distance * Math.cos(angleRad);
                    y += v.distance * Math.sin(angleRad);
                    pathPoints.push({x: x, y: y});
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                });

                const pathWidth = maxX - minX;
                const pathHeight = maxY - minY;
                const pathCenterX = (minX + maxX) / 2;
                const pathCenterY = (minY + maxY) / 2;

                const scaleX = (canvas.width * 0.9) / pathWidth;
                const scaleY = (canvas.height * 0.9) / pathHeight;
                const scale = Math.min(scaleX, scaleY);

                const startX = (canvas.width / 2) - (pathCenterX * scale);
                const startY = (canvas.height / 2) - (pathCenterY * scale);

                ctx.beginPath();
                ctx.moveTo(startX, startY);

                pathPoints.slice(1).forEach(point => {
                    ctx.lineTo(startX + point.x * scale, startY + point.y * scale);
                });
                
                ctx.stroke();
                
                // Points de départ et d'arrivée
                ctx.beginPath();
                ctx.arc(startX, startY, 8, 0, 2 * Math.PI);
                ctx.fillStyle = '#10b981';
                ctx.fill();

                ctx.beginPath();
                ctx.arc(startX + x * scale, startY + y * scale, 8, 0, 2 * Math.PI);
                ctx.fillStyle = '#ef4444';
                ctx.fill();
            };
            
            const updateStats = (vectors) => {
                const totalDistanceCm = vectors.reduce((sum, vector) => sum + vector.distance, 0);
                const totalDistanceM = (totalDistanceCm / 100).toFixed(2);
                totalDistanceDisplay.textContent = `${totalDistanceM} m`;
            };

            const resizeCanvas = (vectors) => {
                const parent = canvas.parentElement;
                canvas.width = parent.clientWidth;
                canvas.height = parent.clientHeight;
                if (vectors && vectors.length > 0) {
                   drawPath(vectors);
                }
            };

            const fetchAndDrawZone = async (zoneName) => {
                loadingIndicator.style.display = 'flex';
                pageTitle.textContent = `Visualisation de: ${zoneName}`;
                try {
                    const response = await fetch(`/api/zone/${zoneName}`);
                    if (!response.ok) throw new Error('Réponse du serveur non valide');
                    
                    const vectors = await response.json();
                    
                    window.addEventListener('resize', () => resizeCanvas(vectors));
                    resizeCanvas(vectors);
                    updateStats(vectors);

                } catch (error) {
                    console.error("Erreur lors du chargement de la zone:", error);
                    loadingIndicator.innerHTML = '<p class="text-red-600 font-semibold">Impossible de charger les données du tracé.</p>';
                }
            };
            
            // --- Point d'entrée ---
            const urlParams = new URLSearchParams(window.location.search);
            const zoneName = urlParams.get('name');

            if (zoneName) {
                fetchAndDrawZone(zoneName);
            } else {
                pageTitle.textContent = 'Erreur';
                loadingIndicator.style.display = 'flex';
                loadingIndicator.innerHTML = '<p class="text-red-600 font-semibold">Aucun nom de zone spécifié dans l\'URL.</p>';
            }
        });
    </script>
</body>
</html>
