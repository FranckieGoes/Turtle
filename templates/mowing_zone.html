<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualisation de la Zone de Tonte</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #1f2937;
        }
        canvas {
            background-color: #e2e8f0;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="bg-gray-100 p-4 sm:p-6">

    <div class="bg-white p-6 sm:p-8 rounded-2xl shadow-xl w-full max-w-2xl text-center">
        <h1 class="text-3xl sm:text-4xl font-bold mb-4 text-indigo-700">Visualisation de la Zone</h1>
        <p class="text-gray-600 mb-6">Tracé du dernier parcours enregistré du robot tondeuse.</p>
        
        <!-- Canvas pour la visualisation -->
        <div class="relative w-full aspect-square">
            <canvas id="mowingCanvas" class="w-full h-full"></canvas>
            <!-- Indicateur de chargement -->
            <div id="loadingIndicator" class="absolute inset-0 flex items-center justify-center bg-white bg-opacity-80 rounded-2xl z-10 hidden">
                <div class="animate-spin rounded-full h-12 w-12 border-4 border-indigo-500 border-t-transparent"></div>
            </div>
        </div>

        <!-- Section pour les informations sur le parcours -->
        <div class="mt-6 text-left">
            <h2 class="text-2xl font-semibold mb-2 text-gray-800">Détails du Parcours</h2>
            <p class="text-gray-600">Distance totale parcourue : <span id="totalDistance" class="font-medium text-gray-800">0 m</span></p>
            <p class="text-gray-600">Temps de tonte : <span id="mowingTime" class="font-medium text-gray-800">0 min</span></p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('mowingCanvas');
            const ctx = canvas.getContext('2d');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const totalDistanceDisplay = document.getElementById('totalDistance');
            const mowingTimeDisplay = document.getElementById('mowingTime');

            // Données de parcours simulées (remplacer par les données du backend)
            // Chaque objet représente un segment de déplacement
            // distance: en unités arbitraires (par exemple, 1 unité = 1 cm)
            // relative_angle: l'angle de rotation par rapport à la direction précédente, en degrés
            const sampleVectors = [
                { distance: 100, relative_angle: 0 },
                { distance: 50, relative_angle: 90 },
                { distance: 150, relative_angle: 0 },
                { distance: 50, relative_angle: 90 },
                { distance: 100, relative_angle: 0 },
                { distance: 50, relative_angle: 90 },
                { distance: 150, relative_angle: 0 },
                { distance: 50, relative_angle: 90 },
            ];

            // Constantes pour le rendu visuel
            const DISTANCE_TO_PIXEL_RATIO = 1; // 1 unité de distance = 1 pixel sur le canvas
            const FADE_IN_TIME = 1000; // Durée du fondu d'apparition en ms

            /**
             * Dessine le chemin de tonte sur le canvas.
             * @param {Array<Object>} vectors - La liste des vecteurs de mouvement.
             */
            const drawPath = (vectors) => {
                loadingIndicator.style.display = 'none';

                // Nettoyer le canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Paramètres de dessin pour le chemin
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Position et angle de départ (au centre, pointant vers le haut)
                let currentX = canvas.width / 2;
                let currentY = canvas.height / 2;
                let currentAngle = -90; // Le "haut" du canvas, en degrés

                // Démarrer le tracé du chemin
                ctx.beginPath();
                ctx.moveTo(currentX, currentY);

                vectors.forEach(vector => {
                    const distance = vector.distance * DISTANCE_TO_PIXEL_RATIO;
                    const relativeAngle = vector.relative_angle;

                    // Mettre à jour l'angle absolu
                    currentAngle += relativeAngle;
                    // Conversion en radians, en ajustant pour que 0° soit vers la droite (Math.cos/sin) et -90° vers le haut
                    const angleRad = (currentAngle) * Math.PI / 180;

                    const newX = currentX + distance * Math.cos(angleRad);
                    const newY = currentY + distance * Math.sin(angleRad);
                    
                    ctx.lineTo(newX, newY);
                    currentX = newX;
                    currentY = newY;
                });
                
                // Dessiner le chemin
                ctx.stroke();
                
                // Dessiner un point de départ
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 2, 8, 0, 2 * Math.PI);
                ctx.fillStyle = '#10b981'; // Vert
                ctx.fill();

                // Dessiner un point d'arrivée
                ctx.beginPath();
                ctx.arc(currentX, currentY, 8, 0, 2 * Math.PI);
                ctx.fillStyle = '#ef4444'; // Rouge
                ctx.fill();
            };

            /**
             * Calcule les statistiques de parcours et les affiche.
             * @param {Array<Object>} vectors - La liste des vecteurs de mouvement.
             */
            const updateStats = (vectors) => {
                const totalDistance = vectors.reduce((sum, vector) => sum + vector.distance, 0);
                const estimatedMowingTime = totalDistance / 1000 * 2; // Exemple: 2 minutes par mètre
                
                totalDistanceDisplay.textContent = `${(totalDistance / 100).toFixed(2)} m`;
                mowingTimeDisplay.textContent = `${estimatedMowingTime.toFixed(0)} min`;
            };

            /**
             * Rend le canvas réactif aux changements de taille de la fenêtre.
             */
            const resizeCanvas = () => {
                const parent = canvas.parentElement;
                canvas.width = parent.clientWidth;
                canvas.height = parent.clientHeight;
                drawPath(sampleVectors);
            };

            // Événement pour gérer le redimensionnement de la fenêtre
            window.addEventListener('resize', resizeCanvas);

            // Simulation du chargement et du dessin initial
            loadingIndicator.style.display = 'flex';
            setTimeout(() => {
                resizeCanvas();
                updateStats(sampleVectors);
            }, 500); // Délai pour simuler le chargement des données
        });
    </script>
</body>
</html>
